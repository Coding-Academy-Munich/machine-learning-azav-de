In Python, a **class** serves as a blueprint for creating user-defined data types that encapsulate both state (attributes) and behavior (methods), defined using the `class` keyword followed by the class name and an optional parent class in parentheses. The `__init__` method functions as the constructor, invoked automatically upon instantiation to initialize instance attributes, with the first parameter conventionally named **self**—a reference to the newly created instance that must be passed explicitly to instance methods. Unlike some object-oriented languages where `this` is implicit, Python requires explicit declaration of `self` as the first positional argument in method definitions, reinforcing the conceptual model that methods are functions bound to objects. Instance attributes are typically established within `__init__` via assignments such as `self.attribute = value`, while **class attributes**—shared across all instances—are defined directly within the class body and can be accessed via both the class and its instances, though mutable class attributes require careful handling to prevent unintended shared state.

Python supports classical object-oriented principles including **inheritance**, where a subclass inherits attributes and methods from a parent class, potentially overriding behavior or extending functionality through `super()` calls that delegate to the next class in the **Method Resolution Order** (MRO). The language provides three distinct method types: **instance methods** (requiring `self`), **class methods** (decorated with `@classmethod`, receiving the class object `cls` as the first argument), and **static methods** (decorated with `@staticmethod`, behaving like plain functions within the class namespace). Encapsulation is implemented through naming conventions rather than strict access control: a single leading underscore `_attribute` signals internal use, while a double underscore `__attribute` triggers **name mangling**—transforming the identifier to `_ClassName__attribute` to prevent accidental access in subclasses. For controlled attribute access, the `@property` decorator enables computed attributes that appear as simple data members while invoking getter, setter, and deleter methods behind the scenes.

Classes in Python are **first-class objects** themselves—instances of the metaclass `type`—allowing runtime introspection via `isinstance()` and `hasattr()`, and enabling metaprogramming patterns where classes are created dynamically or modified after definition. **Special methods** (dunder methods) such as `__repr__`, `__str__`, `__eq__`, and `__len__` integrate custom classes with Python's built-in functions and operators, following the **data model protocol** that specifies how objects behave with respect to iteration, comparison, arithmetic operations, and context management. For example, implementing `__add__` enables the `+` operator, while `__enter__` and `__exit__` allow objects to function as context managers in `with` statements. This protocol-based design allows user-defined classes to seamlessly interoperate with Python's standard library and language syntax, treating custom types as native citizens of the type system.
